<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas width="200" height="200"></canvas>
    <script>
        let g_canvas = document.querySelector("canvas");
        let g_ctx = g_canvas.getContext("2d");
        main();

        function main() {
            const screen = getScreen();
            const buffer = makeImageBuffer(screen);
            const scene = makeGeo();
            const camera = makeCamera();
            renderScene(buffer, scene, camera, screen);
            showImage(buffer);
        }

        function getScreen() {
            return { w: g_canvas.width, h: g_canvas.height }
        }

        function showImage(imageData) {
            g_ctx.putImageData(imageData, 0, 0);
        }

        /** @param {screen} s */
        function makeImageBuffer(s) {
            return g_ctx.createImageData(s.w, s.h);
        }

        /** @returns {vec} */
        function vAdd([ax, ay, az], [bx, by, bz]) {
            return [ax + bx, ay + by, az + bz];
        }

        /** @returns {vec} */
        function vSub([ax, ay, az], [bx, by, bz]) {
            return [ax - bx, ay - by, az - bz];
        }

        function vDot([ax, ay, az], [bx, by, bz]) {
            return ax * bx + ay * by + az * bz;
        }

        /** @returns {vec} */
        function vCross([ax, ay, az], [bx, by, bz]) {
            return [ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx]
        }

        /** @returns {quat} */
        function qFromAxisAngle([x, y, z], a) {
            let s = Math.sin(a / 2);
            return [Math.cos(a / 2), x * s, y * s, z * s];
        }

        /** @returns {[vec, number]} */
        function qToAxisAngle([w, x, y, z]) {
            let s = Math.sqrt(1 - w * w);
            if (Math.abs(s) < 0.001) s = 1;
            return [[x / s, y / s, z / s], 2 * Math.acos(w)]
        }

        /** @returns {quat} */
        function qMult([aw, ax, ay, az], [bw, bx, by, bz]) {
            return [
                aw * bw - ax * bx - ay * by - az * bz,
                ax * bw + aw * bx + ay * bz - az * by,
                aw * by - ax * bz + ay * bw + az * bx,
                aw * bz + ax * by - ay * bx + az * bw
            ]
        }

        /** @returns {vec} */
        function rotate([x, y, z], [rw, rx, ry, rz]) {
            return [
                rw * rw * x + 2 * ry * rw * z - 2 * rz * rw * y + rx * rx * x + 2 * ry * rx * y
                + 2 * rz * rx * z - rz * rz * x - ry * ry * x,
                2 * rx * ry * x + ry * ry * y + 2 * rz * ry * z + 2 * rw * rz * x - rz * rz * y
                + rw * rw * y - 2 * rx * rw * z - rx * rx * y,
                2 * rx * rz * x + 2 * ry * rz * y + rz * rz * z - 2 * rw * ry * x - ry * ry * z
                + 2 * rw * rx * y - rx * rx * z + rw * rw * z,
            ]
        }

        function lerp1(a, b, x) {
            return a + (b - a) * x;
        }

        function degToRad(x) {
            return x / (360 / (2 * Math.PI));
        }

        /** @typedef {[number, number, number]} vec_impl */
        /** @typedef {vec_impl | {x: number, y: number, z: number}} vec */
        /** @typedef {[number, number, number, number]} quat_impl */
        /** @typedef {quat_impl | {x: number, y: number, z: number, w: number}} quat */
        /** @typedef {{c: vec, r: number}} sphere */
        /** @typedef {{u: vec, t: number}} plane */
        /** @typedef {{p: vec, u: vec}} ray */
        /** @typedef {(sphere | plane)[]} geo */
        /** @typedef {{w: number, h: number}} screen */
        /** @typedef {{p: vec, u: quat, hFov: number}} camera */

        /**
         * defines scene geometry as list of objects
         * 
         * my scene is a 2x2x2m box with a sphere in it
         * 
         * directions: up y axis, right x axis
         * units: centimeters
         * 
         * @returns {geo}
         * */
        function makeGeo() {
            return [
                { c: [10, 20, 0], r: 20 },  // sphere
                { u: [1, 0, 0], t: -100 },  // left plane
                { u: [1, 0, 0], t: 100 },  // right plane
                { u: [0, 1, 0], t: 0 },  // floor plane
                { u: [0, 1, 0], t: 200 },  // ceiling plane
                // TODO: light? material camera?
            ]
        }

        /** @returns {camera} */
        function makeCamera() {
            return { p: [0, 100, 0], u: qFromAxisAngle([0, 0, 1], 0), hFov: 70 }
        }

        /**
         * @param {ImageData} buffer
         * @param {geo} geo
         * @param {camera} c
         * @param {screen} s
         */
        function renderScene(buffer, geo, c, s) {
            // camera trace rays equal distance and direction from sensor pos,
            // size, fov (get each pixel initial ray vector)
            for (let i = 0; i < s.h * s.w; i++) {
                const ray = castCameraRay(c, s, i);
                const [x, y, z] = ray.u;
                buffer.data[(i * 4) + 0] = Math.abs(z) * 255;
                buffer.data[(i * 4) + 1] = 0
                buffer.data[(i * 4) + 2] = 0
                buffer.data[(i * 4) + 3] = 255
            }

            // trace scene until collision with sphere or plane
            // calculate reflection angle
            // material can set ratio reflectivity: absorption:,  

            // for (let i = 0; i < buffer.data.length; i += 4) {
            //     buffer.data[i] = 255
            //     buffer.data[i + 1] = 255
            //     buffer.data[i + 2] = 255
            //     buffer.data[i + 3] = 255
            // }
        }

        /** @param {camera} c @param {screen} s */
        function getVFov(c, s) {
            return c.hFov * (s.h / s.w);
        }

        /** @param {camera} c @param {screen} s @param {number} i @returns {ray} */
        function castCameraRay(c, s, i) {
            const row = Math.floor(i / s.w);
            const col = i % s.w;

            const hFov = degToRad(c.hFov);
            const vFov = degToRad(getVFov(c, s));

            const angleW = lerp1(hFov / 2, hFov / 2, col / s.w);
            const angleH = lerp1(vFov / 2, -vFov / 2, row / s.h);

            const qW = qFromAxisAngle([0, 1, 0], angleW);
            const qH = qFromAxisAngle([-1, 0, 0], angleH);

            const q = qMult(qMult(c.u, qW), qH);
            const [axis] = qToAxisAngle(q)
            return { p: c.p, u: axis };
        }

        /** @param {ray} r @param {sphere} s @returns {undefined|vec[]]} */
        function intersectRaySphere(r, s) {
            const L = s.c - r.p;
            const tc = dot(L, r.u);
            if (tc < 0.0) return;
            const d2 = (tc * tc) - (L * L);
            const r2 = s.r * s.r;
            if (d2 > r2) return;
            const t1c = Math.sqrt(r2 - d2);
            return [tc - t1c, tc + t1c];
        }
    </script>
</body>

</html>