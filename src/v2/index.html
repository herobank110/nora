<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas width="200" height="200"></canvas>
    <script>
        let g_canvas = document.querySelector("canvas");
        let g_ctx = g_canvas.getContext("2d");
        main();

        function main() {
            const buffer = makeImageBuffer();
            const scene = makeGeo();
            const camera = makeCamera();
            renderScene(buffer, scene, camera);
            showImage(buffer);
        }

        function showImage(imageData) {
            g_ctx.putImageData(imageData, 0, 0);
        }

        function makeImageBuffer() {
            return g_ctx.createImageData(g_canvas.width, g_canvas.height);
        }

        class Quat {
            /** @param {number} a @param {number} b @param {number} c @param {number} d */
            constructor(a, b, c, d) {
                this.a = a, this.b = b, this.c = c, this.d = d;
            }

            /** @param {Vec} _ @param {number} a */
            static fromAxisAngle({ x, y, z }, a) {
                return new Quat(Math.cos(a / 2), x * sin(a / 2), y * sin(a / 2), z * sin(a / 2));
            }

            /** @param {Quat} other */
            combine(other) {
                return new Quat(1, 2, 3, 4)
            }
        }

        Object.defineProperty(Array.prototype, "x", { get() { return this[0] } })
        Object.defineProperty(Array.prototype, "y", { get() { return this[1] } })
        Object.defineProperty(Array.prototype, "z", { get() { return this[2] } })
        Object.defineProperty(Array.prototype, "w", { get() { return this[3] } })

        /** @typedef {[number, number, number]} vec_impl */
        /** @typedef {vec_impl | {x: number, y: number, z: number}} vec */
        /** @typedef {[number, number, number, number]} quat_impl */
        /** @typedef {quat_impl | {x: number, y: number, z: number, w: number}} quat */
        /** @typedef {{c: vec, r: number}} sphere */
        /** @typedef {{u: vec, t: number}} plane */
        /** @typedef {(sphere | plane)[]} geo */
        /** @typedef {[number, number]} sensor */
        /** @typedef {{p: vec, horizontal_fov: number, sensor: sensor}} camera */

        /**
         * defines scene geometry as list of objects
         * 
         * my scene is a 2x2x2m box with a sphere in it
         * 
         * directions: up y axis, right x axis
         * units: centimeters
         * 
         * @returns {geo}
         * */
        function makeGeo() {
            return [
                { c: [10, 20, 0], r: 20 },  // sphere
                { u: [1, 0, 0], t: -100 },  // left plane
                { u: [1, 0, 0], t: 100 },  // right plane
                { u: [0, 1, 0], t: 0 },  // floor plane
                { u: [0, 1, 0], t: 200 },  // ceiling plane
                // TODO: light? material camera?
            ]
        }

        /** @returns {camera} */
        function makeCamera() {
            return { p: [0, 100, 0], horizontal_fov: 75 }
        }

        /**
         * @param {ImageData} buffer
         * @param {geo} geo
         * @param {camera} camera
         */
        function renderScene(buffer, geo, camera) {

            // camera trace rays equal distance and direction from sensor pos,
            // size, fov (get each pixel initial ray vector)




            // trace scene until collision with sphere or plane
            // calculate reflection angle
            // material can set ratio reflectivity: absorption:,  

            for (let i = 0; i < buffer.data.length; i += 4) {
                buffer.data[i] = 255
                buffer.data[i + 1] = 255
                buffer.data[i + 2] = 255
                buffer.data[i + 3] = 255
            }
        }

        /** 
         * @param {camera} camera
         * @param {number} i
         * @returns {vec} line of ray */
        function castCameraRay(camera, i) {


        }
    </script>
</body>

</html>