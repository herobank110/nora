<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas width="300" height="200"></canvas>
    <script>
        /** @typedef {[number, number, number]} vec (xyz) */
        /** @typedef {[number, number, number, number]} quat  (wxyz) */
        /** @typedef {{c: vec, r: number}} sphere */
        /** @typedef {{u: vec, t: number}} plane */
        /** @typedef {{p: vec, u: vec}} ray */
        /** @typedef {{p: vec, n: vec, g: geo}} hit */
        /** @typedef {(sphere | plane)[]} geo */
        /** @typedef {{w: number, h: number}} screen */
        /** @typedef {{p: vec, fd: vec, rt: vec, up: vec, hFov: number}} camera */


        let g_canvas = document.querySelector("canvas");
        let g_ctx = g_canvas.getContext("2d");
        main();

        function main() {
            const screen = getScreen();
            const buffer = makeImageBuffer(screen);
            const scene = makeGeo();
            const camera = makeCamera();
            renderScene(buffer, scene, camera, screen);
            showImage(buffer);
        }

        function getScreen() {
            return { w: g_canvas.width, h: g_canvas.height }
        }

        function showImage(imageData) {
            g_ctx.putImageData(imageData, 0, 0);
        }

        /** @param {screen} s */
        function makeImageBuffer(s) {
            return g_ctx.createImageData(s.w, s.h);
        }

        /** @returns {vec} */
        function vAdd([ax, ay, az], [bx, by, bz]) {
            return [ax + bx, ay + by, az + bz];
        }

        /** @returns {vec} */
        function vSub([ax, ay, az], [bx, by, bz]) {
            return [ax - bx, ay - by, az - bz];
        }

        /** @returns {vec} */
        function vMul([x, y, z], a) {
            return [x * a, y * a, z * a];
        }

        function vDot([ax, ay, az], [bx, by, bz]) {
            return ax * bx + ay * by + az * bz;
        }

        /** @returns {vec} */
        function vCross([ax, ay, az], [bx, by, bz]) {
            return [ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx]
        }

        function vLen([x, y, z]) {
            return Math.sqrt(x * x + y * y + z * z);
        }

        /** @param {vec} v */
        function vNorm(v) {
            return vMul(v, vLen(v));
        }

        /** @returns {vec} */
        function rotate([x, y, z], [rw, rx, ry, rz]) {
            return [
                rw * rw * x + 2 * ry * rw * z - 2 * rz * rw * y + rx * rx * x + 2 * ry * rx * y
                + 2 * rz * rx * z - rz * rz * x - ry * ry * x,
                2 * rx * ry * x + ry * ry * y + 2 * rz * ry * z + 2 * rw * rz * x - rz * rz * y
                + rw * rw * y - 2 * rx * rw * z - rx * rx * y,
                2 * rx * rz * x + 2 * ry * rz * y + rz * rz * z - 2 * rw * ry * x - ry * ry * z
                + 2 * rw * rx * y - rx * rx * z + rw * rw * z,
            ]
        }

        function lerp1(a, b, x) {
            return a + (b - a) * x;
        }

        function mapRange(x, a, b, c, d) {
            return lerp1(c, d, (x - a) / (b - a));
        }

        function degToRad(x) {
            return x / (360 / (2 * Math.PI));
        }

        /**
         * defines scene geometry as list of objects
         * 
         * my scene is a 2x2x2m box with a sphere in it
         * 
         * directions: up y axis, right x axis
         * units: centimeters
         * 
         * @returns {geo}
         * */
        function makeGeo() {
            return [
                // { c: [10, 20, 0], r: 20 },  // sphere
                { u: [1, 0, 0], t: -100 },  // left plane
                { u: [1, 0, 0], t: 100 },  // right plane
                { u: [0, 1, 0], t: 0 },  // floor plane
                { u: [0, 1, 0], t: 200 },  // ceiling plane
                // TODO: light? material camera?
            ]
        }

        /** @returns {camera} */
        function makeCamera() {
            return { p: [0, 100, 0], fd: [0, 0, 1], rt: [1, 0, 0], up: [0, 1, 0], hFov: 70 }
        }

        /**
         * @param {ImageData} buffer
         * @param {geo} geo
         * @param {camera} c
         * @param {screen} s
         */
        function renderScene(buffer, geo, c, s) {
            for (let i = 0; i < s.h * s.w; i++) {
                const ray = castCameraRay(c, s, i);
                const p = findClosestIntersectingPlane(geo, ray)
                buffer.data[(i * 4) + 0] = [100, 0, 0, 0][p];
                buffer.data[(i * 4) + 1] = [0, 100, 0, 0][p];
                buffer.data[(i * 4) + 2] = [0, 0, 100, 0][p];
                buffer.data[(i * 4) + 3] = 255;
            }
        }

        /** @param {camera} c @param {screen} s */
        function getVFov(c, s) {
            return c.hFov * (s.h / s.w);
        }

        /** @param {camera} c @param {screen} s @param {number} i @returns {ray} */
        function castCameraRay(c, s, i) {
            const hPx = Math.floor(i / s.w)
            const vPx = i % s.w;
            const hFov = c.hFov;
            const vFov = getVFov(c, s);
            const hView = Math.tan(degToRad(hFov) / 2);
            const vView = Math.tan(degToRad(vFov) / 2);
            const hScale = mapRange(hPx, 0, s.h - 1, -hView, hView);
            const vScale = mapRange(vPx, 0, s.w - 1, vView, -vView);
            console.log(`${hScale} ${vScale}`);
            return {
                p: c.p,
                u: vNorm(vAdd(c.fd, vAdd(vMul(c.rt, hScale), vMul(c.up, vScale))))
            };
        }

        // /** @param {ray} r @param {sphere} s @returns {undefined|vec[]]} */
        // function intersectRaySphere(r, s) {
        //     const L = vSub(s.c, r.p);
        //     const tc = vDot(L, r.u);
        //     if (tc < 0.0) return;
        //     const d2 = (tc * tc) - (L * L);
        //     const r2 = s.r * s.r;
        //     if (d2 > r2) return;
        //     const t1c = Math.sqrt(r2 - d2);
        //     const intersections = [tc - t1c, tc + t1c];
        // }

        /** @param {ray} r @param {plane} p @returns {undefined|vec} */
        function intersectRayPlane(r, p) {
            const denom = vDot(p.u, r.u);
            if (Math.abs(denom) <= 1e-4) return;
            const t = -(vDot(p.u, r.p) + p.t) / vDot(p.u, r.u);
            if (t <= 1e-4) return;
            return vAdd(r.p, vMul(r.u, t));
        }

        /** @param {plane[]} ps @param {ray} r @returns {number} plane index */
        function findClosestIntersectingPlane(ps, r) {
            return ps
                .map((p, i) => [i, intersectRayPlane(r, p)])
                .filter(([_, x]) => x)
                .map(([i, x]) => [i, vLen(vSub(x, r.p))])
                .sort(([_, d1], [__, d2]) => d1 - d2)
                .map(([i]) => i)
                .find(_ => 1)
        }

    </script>
</body>

</html>